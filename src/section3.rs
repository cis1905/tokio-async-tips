// Section 3: Common async pitfalls

// Futures generated by async sometimes have limitations that you might not realize. If you uncomment this, it doesn't compile, for example.
use std::{sync::{Mutex, MutexGuard}, time::Duration};

use tokio::time::sleep;
// async fn foo(){
//     let mutex = Mutex::new(0);
//     tokio::spawn(async {
//         let lock = mutex.lock().unwrap();
//         sleep(Duration::from_millis(500)).await;
//         println!("{:?}", &* lock);
//     }).await.unwrap();
// }

// This is due to an internal detail of async that lets it generate efficient Futures, but sometimes causes them to not work in a thread-safe way.
// This most often happens when using mutexes across await boundaries.
// My best advice is to *not* use your lock across those boundaries. Use a block to end your lock's lifetime and drop it before the await piont.
// If you must hold the lock, then use a Mutex from Tokio or from parking_lot instead. Those are designed to pass locks around in this way.
// Alternatively, if you have the opportunity to use a different executor besides tokio, there are executors that don't require that you are able to Send the Future across threads.